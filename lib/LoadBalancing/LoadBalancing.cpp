#include "LoadBalancing.h"

#include <math.h>

/*
 * This file is part of the ArduinoEVSE (https://github.com/tomwetjens/ArduinoEVSE).
 * Copyright (c) 2023 Tom Wetjens.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

float LoadBalancing::calculateMaxImportCurrent()
{
    // Determine the current load on the mains (highest of the 3 phases)
    auto importCurrent = mainsMeter->importCurrent();
    float mainsLoad = fmax(0, fmax(importCurrent.l1, fmax(importCurrent.l2, importCurrent.l3)));

    // Take out the load generated by the charger itself currently
    float houseLoad = mainsLoad - chargeController->actualCurrent(); // can be negative, meaning some power is also generated

    // Calculate max current charger may take, giving priority to the house load
    return fmin(chargeController->maxCurrent(), fmax(0, settings.maxMainsCurrent - houseLoad));
}

void LoadBalancing::balanceLoad()
{
    unsigned long now = millis();

    // If any meter values changed since the last time we checked
    if (mainsMeter->updated() - lastChecked > 0 || chargeController->actualCurrentUpdated() - lastChecked > 0)
    {
        // Only when all required meter values are recent
        if (now - mainsMeter->updated() < settings.meterTimeout && now - chargeController->actualCurrentUpdated() < settings.meterTimeout)
        {
            float maxImportCurrent = calculateMaxImportCurrent();

            // TODO: Increasing the charging current limit should be debounced to prevent too much fluctuations and/or relay switching (decreasing should be immediate, for safety)
            setCurrentLimit(maxImportCurrent);
        }

        lastChecked = now;
    }
}

bool LoadBalancing::fallbackEnabled()
{
    return settings.fallbackTimeout > 0;
}

void LoadBalancing::fallbackCurrentIfOutdated()
{
    if (fallbackEnabled())
    {
        // When state is initial or current limit is outdated
        if (millis() - currentLimitLastUpdated >= settings.fallbackTimeout)
        {
            // Fall back to a safe charging current (for safety reasons)
            fallbackCurrent();
        }
    }
}

void LoadBalancing::fallbackCurrent()
{
    // When not already at a safe current
    if (chargeController->getCurrentLimit() > settings.fallbackCurrent)
    {
        Serial.println("Current limit timeout. Falling back to safe charging current");
        chargeController->setCurrentLimit(settings.fallbackCurrent);
    }
}

LoadBalancing::LoadBalancing(ChargeController &chargeController, MainsMeter &mainsMeter)
{
    this->chargeController = &chargeController;
    this->mainsMeter = &mainsMeter;
}

void LoadBalancing::setup(LoadBalancingSettings settings)
{
    this->settings = settings;

    auto now = millis();
    // Pretend it was 'infinitely' long ago
    currentLimitLastUpdated = now - UINT64_MAX;
    lastChecked = now - UINT64_MAX;

    if (fallbackEnabled())
    {
        fallbackCurrent();
    }
}

void LoadBalancing::loop()
{
    balanceLoad();
    fallbackCurrentIfOutdated();
}

void LoadBalancing::setCurrentLimit(float amps)
{
    chargeController->setCurrentLimit(amps);
    currentLimitLastUpdated = millis();
}
